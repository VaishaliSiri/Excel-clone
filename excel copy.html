<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrollable Grid with Scrollbars</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #grid-container {
            position: absolute;
            top: 30px;
            left: 50px;
            right: 0;
            bottom: 0;
            overflow: auto;
        }
        
        #grid-content {
            width: 100000px; /* totalCols * cellWidth */
            height: 3000000px; /* totalRows * cellHeight */
            position: relative;
        }
        
        #grid {
            position: absolute;
            top: 0;
            left: 0;
            cursor: cell;
        }

        
        #column-header {
            position: fixed;
            top: 0;
            left: 50px;
            right: 0;
            height: 30px;
            background: #f0f0f0;
            border-bottom: 1px solid #999;
            z-index: 10;
            overflow: hidden;
        }
        
        #row-header {
            position: fixed;
            top: 30px;
            left: 0;
            width: 50px;
            bottom: 0;
            background: #f0f0f0;
            border-right: 1px solid #999;
            z-index: 10;
            overflow: hidden;
        }
        
        #corner-header {
            position: fixed;
            top: 0;
            left: 0;
            width: 50px;
            height: 30px;
            background: #f0f0f0;
            border-right: 1px solid #999;
            border-bottom: 1px solid #999;
            z-index: 20;
        }
        
        .header-canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="corner-header"></div>
        <div id="column-header">
            <canvas id="column-canvas" class="header-canvas"></canvas>
        </div>
        <div id="row-header">
            <canvas id="row-canvas" class="header-canvas"></canvas>
        </div>
        <div id="grid-container">
            <div id="grid-content">
                <canvas id="grid">
                </canvas>
            </div>
        </div>
        <input id="text-field" type="text" style="
    position: absolute;
    display: none;
    font-size: 14px;
    border: 1px solid #4CAF50;
    outline: none;
    padding: 4px;
    z-index: 50;
    box-sizing: border-box;
"/>

    </div>

    <script>
        const data = {};
        const gridCanvas = document.getElementById("grid");
        const columnCanvas = document.getElementById("column-canvas");
        const rowCanvas = document.getElementById("row-canvas");
        const gridContainer = document.getElementById("grid-container");
        
        const gridCtx = gridCanvas.getContext("2d");
        const columnCtx = columnCanvas.getContext("2d");
        const rowCtx = rowCanvas.getContext("2d");

        const cellWidth = 100;
        const cellHeight = 30;
        const headerHeight = 30;
        const headerWidth = 50;

        const totalCols = 500;
        const totalRows = 100000;

        let selectedCell = null;
        let lastScrollLeft = 0;
        let lastScrollTop = 0;

        let selectionStart = null;
        let selectionEnd = null;
        let isSelecting = false;
        let editingCell = null;

        // Set canvas sizes
        function resizeCanvases() {
            // Grid canvas - make it large enough for virtual scrolling
            gridCanvas.width = window.innerWidth;
            gridCanvas.height = window.innerHeight;
            
            // Column header canvas
            columnCanvas.width = window.innerWidth - headerWidth;
            columnCanvas.height = headerHeight;
            
            // Row header canvas  
            rowCanvas.width = headerWidth;
            rowCanvas.height = window.innerHeight - headerHeight;
            
            drawAll();
        }

        // Initial resize
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Utility: Convert number to Excel column letters
        function getColumnLetter(n) {
            let result = "";
            while (n >= 0) {
                result = String.fromCharCode((n % 26) + 65) + result;
                n = Math.floor(n / 26) - 1;
            }
            return result;
        }

        // Draw main grid
        function drawGrid() {
            const scrollLeft = gridContainer.scrollLeft;
            const scrollTop = gridContainer.scrollTop;
            
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

            const visibleCols = Math.ceil(gridCanvas.width / cellWidth) + 2;
            const visibleRows = Math.ceil(gridCanvas.height / cellHeight) + 2;

            const startCol = Math.floor(scrollLeft / cellWidth);
            const startRow = Math.floor(scrollTop / cellHeight);

            const offsetX = -(scrollLeft % cellWidth);
            const offsetY = -(scrollTop % cellHeight);

            // Draw cell backgrounds and selection highlights
            for (let r = 0; r < visibleRows; r++) {
                for (let c = 0; c < visibleCols; c++) {
                    const rowIndex = startRow + r;
                    const colIndex = startCol + c;
                    const x = c * cellWidth + offsetX;
                    const y = r * cellHeight + offsetY;
                    
                    // Check if this cell is in the selection
                    let isSelected = false;
                    if (selectionStart && selectionEnd) {
                        const minRow = Math.min(selectionStart.row, selectionEnd.row);
                        const maxRow = Math.max(selectionStart.row, selectionEnd.row);
                        const minCol = Math.min(selectionStart.col, selectionEnd.col);
                        const maxCol = Math.max(selectionStart.col, selectionEnd.col);
                        
                        if (rowIndex >= minRow && rowIndex <= maxRow && 
                            colIndex >= minCol && colIndex <= maxCol) {
                            isSelected = true;
                        }
                    }
                    
                    // Draw cell background
                    if (isSelected && !(rowIndex === selectionStart.row && colIndex === selectionStart.col)) {
                        // Selected cells (except the first one) get light green background
                        gridCtx.fillStyle = "#E7F2ED";
                    } else {
                        // Normal cells get white background
                        gridCtx.fillStyle = "white";
                    }
                    gridCtx.fillRect(x, y, cellWidth, cellHeight);
                }
            }

            // Draw grid lines
            gridCtx.strokeStyle = "#ddd";
            gridCtx.lineWidth = 0.5;
            
            // Vertical lines
            for (let c = 0; c <= visibleCols; c++) {
                const x = c * cellWidth + offsetX + 0.5;
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, gridCanvas.height);
                gridCtx.stroke();
            }

            // Horizontal lines
            for (let r = 0; r <= visibleRows; r++) {
                const y = r * cellHeight + offsetY + 0.5;
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(gridCanvas.width, y);
                gridCtx.stroke();
            }

            // Draw cell content (text) - this comes AFTER backgrounds and grid lines
            gridCtx.fillStyle = "black";
            gridCtx.font = "12px Arial";
            gridCtx.textAlign = "left";
            gridCtx.textBaseline = "middle";
            
            for (let r = 0; r < visibleRows; r++) {
                for (let c = 0; c < visibleCols; c++) {
                    const rowIndex = startRow + r;
                    const colIndex = startCol + c;
                    
                    if (rowIndex >= 0 && rowIndex < totalRows && colIndex >= 0 && colIndex < totalCols) {
                        const cellValue = (data[rowIndex] && data[rowIndex][colIndex]) || "";
                        if (cellValue) {
                            const x = c * cellWidth + offsetX + 4;
                            const y = r * cellHeight + offsetY + cellHeight / 2;
                            gridCtx.fillText(cellValue, x, y);
                        }
                    }
                }
            }

            // Draw selection border (the green outline)
            if (selectionStart && selectionEnd) {
                const minRow = Math.min(selectionStart.row, selectionEnd.row);
                const maxRow = Math.max(selectionStart.row, selectionEnd.row);
                const minCol = Math.min(selectionStart.col, selectionEnd.col);
                const maxCol = Math.max(selectionStart.col, selectionEnd.col);

                const x = (minCol - startCol) * cellWidth + offsetX + 0.5;
                const y = (minRow - startRow) * cellHeight + offsetY + 0.5;
                const width = (maxCol - minCol + 1) * cellWidth - 1;
                const height = (maxRow - minRow + 1) * cellHeight - 1;

                gridCtx.strokeStyle = "green";
                gridCtx.lineWidth = 2;
                gridCtx.strokeRect(x, y, width, height);
            }
        }

        // Draw column headers
        function drawColumnHeaders() {
            const scrollLeft = gridContainer.scrollLeft;
            
            columnCtx.clearRect(0, 0, columnCanvas.width, columnCanvas.height);
            columnCtx.fillStyle = "#f0f0f0";
            columnCtx.fillRect(0, 0, columnCanvas.width, headerHeight);

            const visibleCols = Math.ceil(columnCanvas.width / cellWidth) + 2;
            const startCol = Math.floor(scrollLeft / cellWidth);
            const offsetX = -(scrollLeft % cellWidth);

            // Draw column separators
            columnCtx.strokeStyle = "#999";
            columnCtx.lineWidth = 0.5;
            for (let c = 0; c <= visibleCols; c++) {
                const x = c * cellWidth + offsetX + 0.5;
                columnCtx.beginPath();
                columnCtx.moveTo(x, 0);
                columnCtx.lineTo(x, headerHeight);
                columnCtx.stroke();
            }

            // Draw column labels
            columnCtx.fillStyle = "black";
            columnCtx.font = "12px Arial";
            columnCtx.textAlign = "center";
            for (let c = 0; c < visibleCols; c++) {
                const colIndex = startCol + c;
                if (colIndex >= 0 && colIndex < totalCols) {
                    const x = c * cellWidth + offsetX + cellWidth / 2;
                    if (x >= 0 && x < columnCanvas.width) {
                        columnCtx.fillText(getColumnLetter(colIndex), x, 20);
                    }
                }
            }
        }

        // Draw row headers
        function drawRowHeaders() {
            const scrollTop = gridContainer.scrollTop;
            
            rowCtx.clearRect(0, 0, rowCanvas.width, rowCanvas.height);
            rowCtx.fillStyle = "#f0f0f0";
            rowCtx.fillRect(0, 0, headerWidth, rowCanvas.height);

            const visibleRows = Math.ceil(rowCanvas.height / cellHeight) + 2;
            const startRow = Math.floor(scrollTop / cellHeight);
            const offsetY = -(scrollTop % cellHeight);

            // Draw row separators
            rowCtx.strokeStyle = "#999";
            rowCtx.lineWidth = 0.5;
            for (let r = 0; r <= visibleRows; r++) {
                const y = r * cellHeight + offsetY + 0.5;
                rowCtx.beginPath();
                rowCtx.moveTo(0, y);
                rowCtx.lineTo(headerWidth, y);
                rowCtx.stroke();
            }

            // Draw row labels
            rowCtx.fillStyle = "black";
            rowCtx.font = "12px Arial";
            rowCtx.textAlign = "center";
            for (let r = 0; r < visibleRows; r++) {
                const rowIndex = startRow + r;
                if (rowIndex >= 0 && rowIndex < totalRows) {
                    const y = r * cellHeight + offsetY + cellHeight / 2 + 4;
                    if (y >= 0 && y < rowCanvas.height) {
                        rowCtx.fillText(rowIndex + 1, headerWidth / 2, y);
                    }
                }
            }
        }

        function drawAll() {
            drawGrid();
            drawColumnHeaders();
            drawRowHeaders();
        }

        // Handle scrolling
        gridContainer.addEventListener('scroll', () => {
            const scrollLeft = gridContainer.scrollLeft;
            const scrollTop = gridContainer.scrollTop;

            // Move canvas with scroll to stay on top of visible content
            gridCanvas.style.transform = `translate(${scrollLeft}px, ${scrollTop}px)`;

            drawAll();
            
            // Update input position if editing
            if (editingCell) {
                updateInputPosition();
            }
        });

        const cellInput = document.getElementById("text-field");

        function updateInputPosition() {
            if (!editingCell) return;
            
            const scrollLeft = gridContainer.scrollLeft;
            const scrollTop = gridContainer.scrollTop;
            const { row, col } = editingCell;
            
            const inputX = (col * cellWidth) - scrollLeft + 50;
            const inputY = (row * cellHeight) - scrollTop + 30;
            
            cellInput.style.left = `${inputX}px`;
            cellInput.style.top = `${inputY}px`;
        }

        function startCellEdit(row, col) {
            editingCell = { row, col };
            
            const scrollLeft = gridContainer.scrollLeft;
            const scrollTop = gridContainer.scrollTop;
            
            const inputX = (col * cellWidth) - scrollLeft + 50;
            const inputY = (row * cellHeight) - scrollTop + 30;

            const cellValue = (data[row] && data[row][col]) || "";

            cellInput.style.left = `${inputX}px`;
            cellInput.style.top = `${inputY}px`;
            cellInput.style.width = `${cellWidth - 2}px`;
            cellInput.style.height = `${cellHeight - 2}px`;
            cellInput.value = cellValue;
            cellInput.style.display = "block";
            cellInput.focus();
            cellInput.select();
        }

        function saveEditingCell() {
            if (editingCell) {
                const value = cellInput.value;
                const { row, col } = editingCell;

                if (!data[row]) data[row] = {};
                data[row][col] = value;

                editingCell = null;
                cellInput.style.display = "none";
                drawGrid(); // Refresh grid to reflect new data
                
                console.log(`Saved: ${getColumnLetter(col)}${row + 1} = "${value}"`);
                console.log("Current data:", data);
            }
        }

        let mouseDownTime = 0;
        let mouseDownPos = null;
        let hasDragged = false;

        // Handle mouse down - start selection or prepare for editing
        gridCanvas.addEventListener("mousedown", (e) => {
            // If we're currently editing, save first
            if (editingCell) {
                saveEditingCell();
                return;
            }
            
            mouseDownTime = Date.now();
            mouseDownPos = { x: e.clientX, y: e.clientY };
            hasDragged = false;
            
            const rect = gridCanvas.getBoundingClientRect();
            const scrollLeft = gridContainer.scrollLeft;
            const scrollTop = gridContainer.scrollTop;

            const x = e.clientX - rect.left + scrollLeft;
            const y = e.clientY - rect.top + scrollTop;

            const col = Math.floor(x / cellWidth);
            const row = Math.floor(y / cellHeight);

            if (col >= 0 && col < totalCols && row >= 0 && row < totalRows) {
                selectionStart = { row, col };
                selectionEnd = { row, col };
                selectedCell = { row, col };
                isSelecting = true;
                drawGrid();
            }
        });

        gridCanvas.addEventListener("mousemove", (e) => {
            if (!isSelecting || editingCell) return;

            // Check if mouse has moved enough to be considered a drag
            if (mouseDownPos && !hasDragged) {
                const distance = Math.sqrt(
                    Math.pow(e.clientX - mouseDownPos.x, 2) + 
                    Math.pow(e.clientY - mouseDownPos.y, 2)
                );
                if (distance > 3) { // 3px threshold
                    hasDragged = true;
                }
            }

            const rect = gridCanvas.getBoundingClientRect();
            const scrollLeft = gridContainer.scrollLeft;
            const scrollTop = gridContainer.scrollTop;

            const x = e.clientX - rect.left + scrollLeft;
            const y = e.clientY - rect.top + scrollTop;

            const col = Math.floor(x / cellWidth);
            const row = Math.floor(y / cellHeight);

            if (col >= 0 && col < totalCols && row >= 0 && row < totalRows &&
                (selectionEnd.row !== row || selectionEnd.col !== col)) {
                selectionEnd = { row, col };
                drawGrid();
            }
        });

        document.addEventListener("mouseup", (e) => {
            if (isSelecting) {
                isSelecting = false;
                
                // Only start editing if it was a click (not a drag) and within a reasonable time
                const clickTime = Date.now() - mouseDownTime;
                if (!hasDragged && clickTime < 300 && selectionStart && 
                    selectionStart.row === selectionEnd.row && 
                    selectionStart.col === selectionEnd.col) {
                    
                    // Start editing the cell
                    startCellEdit(selectionStart.row, selectionStart.col);
                    console.log(`Selected cell: ${getColumnLetter(selectionStart.col)}${selectionStart.row + 1}`);
                } else if (hasDragged) {
                    console.log("Selected range:", selectionStart, selectionEnd);
                }
                
                // Reset tracking variables
                mouseDownTime = 0;
                mouseDownPos = null;
                hasDragged = false;
            }
        });

        // Input field event handlers
        cellInput.addEventListener("blur", saveEditingCell);

        cellInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                saveEditingCell();
            } else if (e.key === "Escape") {
                e.preventDefault();
                editingCell = null;
                cellInput.style.display = "none";
                drawGrid();
            }
        });

        // Initial draw
        drawAll();
    </script>
</body>
</html>